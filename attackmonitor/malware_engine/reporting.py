from enhancers.enhancer_process_tree import enhancer_process_tree
from utils import nicedate
from utils import configer
import copy

from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import *
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.enums import *
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from anytree import Node, RenderTree, Resolver, ResolverError, ChildResolverError, find

class Reporting():

    def __init__(self, GATHERING_OPTIONS, CONTAINERS, PROCESS_TREE):
        self.report_date = nicedate.NiceDate.get_now()

        self.timezone = nicedate.CONFIG_TIMEZONE
        self.CONTAINERS = CONTAINERS
        self.GATHERING_OPTIONS = GATHERING_OPTIONS
        self.PROCESS_TREE = PROCESS_TREE
        self.report_filename = self.GATHERING_OPTIONS['report_dir'] + "\\" + "malware_report_" + self.report_date.strftime("%Y-%m-%d %H_%M_%S") + ".pdf"
        self.canvas = canvas.Canvas(self.report_filename, pagesize=A4)

        #PDF
        self.pdf_initalize_styles()
        self.f = []
        self.doc = SimpleDocTemplate(self.report_filename)

    def load_font(self):
        cc = configer.Config()

        freeserif_font = cc.get_font_path()
        pdfmetrics.registerFont(TTFont("freeserif", freeserif_font))



    def pdf_initalize_styles(self):
        self.load_font()
        self.styles = getSampleStyleSheet()

        # ADD CUSTOM STYLES
        self.styles.add(ParagraphStyle(name='subtitle',
                                       parent=self.styles['Normal'],
                                       fontSize=12,
                                       leading=22,
                                       alignment=TA_CENTER,
                                       spaceAfter=6), alias='subtitle',

                        )

        self.styles.add(ParagraphStyle(name='bigtitle',
                                       parent=self.styles['title'],
                                       fontSize=30,
                                       leading=22,
                                       alignment=TA_CENTER,
                                       spaceAfter=6), alias='bigtitle')

        self.styles.add(ParagraphStyle(name='italictitle',
                                   parent=self.styles['Italic'],
                                   fontSize=12,
                                   leading=22,
                                   alignment=TA_CENTER,
                                   spaceAfter=6), alias='italictitle')

        self.styles.add(ParagraphStyle(name="commandline",
                                       parent=self.styles['Italic'],
                                       fontName="freeserif",
                                       fontSize=8,
                                       leading=12,
                                       leftIndent=0,
                                       alignment=TA_RIGHT,
                                       spaceAfter=6),
                        alias="commandline")

        for i in range(0,9):
            style_name = "dynamicindent" + str(i)
            power_factor = 6
            self.styles.add(ParagraphStyle(name=style_name,
                                           parent=self.styles['Normal'],
                                           fontName="freeserif",
                                           fontSize=12,
                                           leading=12,
                                           leftIndent=i*power_factor,
                                           alignment=TA_LEFT,
                                           spaceAfter=6),
                            alias=style_name)

    def is_the_same_proc(self, pa, pfull):
        if pa.pid == pfull.pid and pa.start_nice_date == pa.start_nice_date:
            return True
        return False

    def is_proc_interesting(self, pfull):
        for pa in self.CONTAINERS['MALWARE_INTERESTING_PIDS']:
            if self.is_the_same_proc(pa, pfull):
                return True
        return False

    def generate_process_tree(self):
        proc_tree_copy = copy.deepcopy(self.PROCESS_TREE)
        proc_tree_untouched = copy.deepcopy(proc_tree_copy)

        ROOT = Node(name="root", proc=None)
        EXISTINGS_PIDS = {int(pid.split("_")[0]) for pid in proc_tree_copy.keys()}

        r = Resolver('name')
        while len(proc_tree_copy) > 0:
            for proc_item in list(proc_tree_copy.items()):
                key = proc_item[0]
                proc = proc_item[1]
                parent_proc = None
                try:
                    parent_proc = proc_tree_untouched["{}_0".format(proc.ppid)]
                except Exception:
                    pass

                #INTERESTING?
                interesting = False
                interesting_parent = False
                if self.is_proc_interesting(proc):
                    interesting = True

                if not parent_proc is None and self.is_proc_interesting(parent_proc):
                    interesting_parent = True

                pid = proc.pid
                ppid = proc.ppid

                try:
                    if interesting:
                        if interesting_parent:
                            #EXISTS
                            parent_node = find(ROOT, filter_=lambda node: node.name == str(ppid), maxlevel=1000)
                            if parent_node is None:
                                continue
                            else:
                                Node(name=str(pid), parent=parent_node, proc=proc)
                                del proc_tree_copy[key]
                        else:
                            Node(name=str(pid), parent=ROOT, proc=proc)
                            del proc_tree_copy[key]
                    else:
                        del proc_tree_copy[key]

                except ResolverError:
                    pass
                except ChildResolverError:
                    pass
                except IndexError:
                    pass
                #sys.exit(0)

        prev_space_count = 0
        for pre, fill, node in RenderTree(ROOT):
            proc = node.proc
            if proc is None:
                self.f.append(self.paragraph("<ROOT>\n".format(pre.replace(" ", "&nbsp;")), 'dynamicindent0'))
            else:
                self.f.append(self.paragraph("{}{} ({})".format(pre.replace(" ", "&nbsp;"), proc.image, proc.pid), 'dynamicindent0'))
                self.f.append(self.paragraph("Command line:{}".format(proc.commandline), "commandline"))



        #print(RenderTree(ROOT))
        '''#print("{} -> {}".format(pid, ppid))
                if not ppid in EXISTINGS_PIDS or pid == ppid:
                    if interesting:
                        Node(name=str(pid), parent=ROOT, proc=proc)
                    else:
                        EXISTINGS_PIDS.add(ppid)
                    del proc_tree_copy[key]
                    continue

                try:
                    parent_node = find(ROOT, filter_=lambda node: node.name == str(ppid), maxlevel=1000)
                    if not parent_node is None:
                        if interesting:
                            Node(name=str(pid), parent=parent_node, proc=proc)
                        else:
                            EXISTINGS_PIDS.add(ppid)
                        del proc_tree_copy[key]
                        continue'''


    def generate_dns_queries(self):
        table = list()
        table.append(["Query", "Type",])
        for mbu in list(self.CONTAINERS['DNS_QUERIES']):
            dq = mbu.data
            domain = dq.domain
            record_type = dq.record_type
            table.append([domain, record_type,])
        self.add_table(table)

    def after_subsection(self):
        self.f.append(Spacer(10, 50))

    def generate(self):
        self.title_page()

        self.add_section("I. Summary of malware actions")

        self.add_subsection("1. Process tree")
        self.generate_process_tree()
        self.after_subsection()

        self.add_subsection("2. DNS requests")
        self.generate_dns_queries()
        self.after_subsection()

        self.doc.build(self.f)

    def paragraph(self, text, style='Normal'):
        return Paragraph(text, style=self.styles[style])

    def title_page(self):
        title = 'Malware analysis report'
        date = "{} ({} timezone)".format(self.report_date.strftime("%d %B %Y"), self.timezone)
        extra = "Generated by Malware Monitor"
        self.f.append(self.paragraph(title, 'bigtitle'))
        self.f.append(Spacer(10,20))
        self.f.append(self.paragraph(date, 'subtitle'))
        self.f.append(Spacer(10, 500))
        self.f.append(self.paragraph(extra, 'italictitle'))
        self.f.append(PageBreak())

    def add_section(self, text):
        self.f.append(self.paragraph(text, 'Heading1'))

    def add_subsection(self, text):
        self.f.append(self.paragraph(text, 'Heading2'))

    def add_paragraph(self, lines):
        if type(lines) is list:
            for line in lines:
                self.f.append(self.paragraph(line, 'Normal'))
        elif type(lines) is str:
            self.f.append(self.paragraph(lines, 'Normal'))

    def add_table(self, data):
        t = Table(data)
        t.setStyle(TableStyle([('TEXTCOLOR', (0, 0), (1, -1), colors.black),]))
        self.f.append(t)
